from pymtl3.dsl import Expr, Const, _T
from typing import Any, Union, TypeVar, Optional, Generic
from typing_extensions import Protocol

# Meta type
class HardwareMetaDataType( type ): ...

# Top type
class HardwareDataType: ...

_AnyInternalBits = TypeVar('_AnyInternalBits', bound = _BitsTop)
# _AnyInternalBits = TypeVar('_AnyInternalBits', covariant = True, bound = _BitsTop)
# _AnyBits = TypeVar('_AnyBits', bound = _Bits[_BitsTop])

NumericalValueType = Union[ int, Expr[_Bits[_AnyInternalBits]] ]

def mk_bits( nbits: int ) -> BitsType: ...

# Meta type
# One error messages from mypy states that:
# Mypy only supports metaclasses inheriting from "type"
# https://github.com/python/mypy/issues/2818

class BitsType( HardwareMetaDataType ): ...
class BitStructType( HardwareMetaDataType ): ...

# Type hierarchy

# Top of BitsN types
class _Bits( HardwareDataType, Generic[_AnyInternalBits] ):
  def __init__( self, value: NumericalValueType[_AnyInternalBits] ) -> None: ...

  def __add__( self: _Bits[_AnyInternalBits], other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...
  # def __sub__( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...
  # def __and__( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...
  # def __or__ ( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...
  # def __xor__( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...

  def __radd__( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...
  # def __rsub__( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...
  # def __rand__( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...
  # def __ror__ ( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...
  # def __rxor__( self, other: Expr[_Bits[_AnyInternalBits]] ) -> Expr[_Bits[_AnyInternalBits]]: ...

  def __getitem__( self, index: NumericalValueType ) -> Expr[Bits1]: ...

# Abstract Bits type
# Bits has the type signatures of operations available to a BitsN object. But instead
# of expecting a concrete BitsN object, most of these operations expect and return
# a Bits abstract Bits object.
# class Bits( _abstract_Bits, CoerciveBits[Bits], metaclass = BitsType ):
# class Bits( _abstract_Bits, metaclass = HardwareMetaDataType ):

# This might not be much helpful because the right way to create a parametrized
# constant is to do Const[T]( value ). This is equivalent to casting `value` into
# data type `T`.
# class Bits( _abstract_Bits, metaclass = BitsType ):
  # def __init__( self, value: AbstractNumericalValueType[Bits] ) -> None: ...

  # def __add__( self, other: Expr[Bits] ) -> Expr[Bits]: ...
  # def __sub__( self, other: Expr[Bits] ) -> Expr[Bits]: ...
  # def __and__( self, other: Expr[Bits] ) -> Expr[Bits]: ...
  # def __or__ ( self, other: Expr[Bits] ) -> Expr[Bits]: ...
  # def __xor__( self, other: Expr[Bits] ) -> Expr[Bits]: ...

  # def __radd__( self, other: Expr[Bits] ) -> Expr[Bits]: ...
  # def __rsub__( self, other: Expr[Bits] ) -> Expr[Bits]: ...
  # def __rand__( self, other: Expr[Bits] ) -> Expr[Bits]: ...
  # def __ror__ ( self, other: Expr[Bits] ) -> Expr[Bits]: ...
  # def __rxor__( self, other: Expr[Bits] ) -> Expr[Bits]: ...

  # def __getitem__( self, index: NumericalValueType ) -> Bits1: ...

  # def __lshift__( self, other: _Bits ) -> Expr[_Bits[_BitsTypeVar]]: ...
  # def __rshift__( self, other: _Bits ) -> Expr[_Bits[_BitsTypeVar]]: ...
  # def __eq__( self, other: Any ) -> Expr[_Bits[_BitsTypeVar]]: ... # type: ignore
  # def __ne__( self, other: Any ) -> Expr[_Bits[_BitsTypeVar]]: ... # type: ignore
  # def __lt__( self, other: Any ) -> Expr[_Bits[_BitsTypeVar]]: ...
  # def __le__( self, other: Any ) -> Expr[_Bits[_BitsTypeVar]]: ...
  # def __gt__( self, other: Any ) -> Expr[_Bits[_BitsTypeVar]]: ...
  # def __ge__( self, other: Any ) -> Expr[_Bits[_BitsTypeVar]]: ...

class _BitsTop: ...

# Concrete BitsN type
# class Bits1( _concrete_Bits, CoerciveBits[Bits1], metaclass = BitsType ):
# class Bits1( _concrete_Bits, metaclass = HardwareMetaDataType ):
class _Bits1(_BitsTop): ...
class Bits1( _Bits[_Bits1], metaclass = BitsType ): ...
# Bits1 = _Bits[_Bits1]
# class Bits1( _concrete_Bits, metaclass = BitsType ):
  # def __init__( self, value: ConcreteNumericalValueType[Bits1] ) -> None: ...

  # def __add__( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...
  # def __sub__( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...
  # def __and__( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...
  # def __or__ ( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...
  # def __xor__( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...

  # def __radd__( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...
  # def __rsub__( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...
  # def __rand__( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...
  # def __ror__ ( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...
  # def __rxor__( self, other: Expr[Bits1] ) -> Expr[Bits1]: ...

  # def __getitem__( self, index: NumericalValueType ) -> Bits1: ...
b1 = Bits1

# class Bits32( _concrete_Bits, CoerciveBits[Bits32], metaclass = BitsType ):
# class Bits32( _concrete_Bits, metaclass = HardwareMetaDataType ):
class _Bits32(_BitsTop): ...
class Bits32( _Bits[_Bits32], metaclass = BitsType ): ...
# class Bits32( _concrete_Bits, metaclass = BitsType ):
  # def __init__( self, value: ConcreteNumericalValueType[Bits32] ) -> None: ...

  # def __add__( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...
  # def __sub__( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...
  # def __and__( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...
  # def __or__ ( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...
  # def __xor__( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...

  # def __radd__( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...
  # def __rsub__( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...
  # def __rand__( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...
  # def __ror__ ( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...
  # def __rxor__( self, other: Expr[Bits32] ) -> Expr[Bits32]: ...

  # def __getitem__( self, index: NumericalValueType ) -> Bits1: ...
b32 = Bits32

#=========================================================================
# BitStruct types
#=========================================================================

class BitStruct( HardwareDataType ): ...

_MEM_MSG_OPQ_TV = TypeVar("_MEM_MSG_OPQ_TV", bound = _Bits)
_MEM_MSG_LEN_TV = TypeVar("_MEM_MSG_LEN_TV", bound = _Bits)
_MEM_MSG_DAT_TV = TypeVar("_MEM_MSG_DAT_TV", bound = _Bits)

class MemReqMsgType(
    BitStruct,
    Generic[_MEM_MSG_OPQ_TV, _MEM_MSG_LEN_TV, _MEM_MSG_DAT_TV],
    metaclass = BitStructType,
  ):
  def __init__( s ) -> None: ...
