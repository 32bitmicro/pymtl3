# from pymtl3.datatypes import Bits1, HardwareDataType, HardwareMetaDataType, NumericalValueType, \
from pymtl3.datatypes import Bits1, HardwareDataType, HardwareMetaDataType, \
                             _Bits, _BitsTop, NumericalValueType
from typing import Sequence, Generic, TypeVar, Any, Union, Optional, Callable, overload
from typing_extensions import Protocol

_AnyBits = TypeVar('_AnyBits', covariant = True, bound = _Bits[_BitsTop])
_T  = TypeVar('_T', bound = HardwareDataType)
# _BitsT  = TypeVar('_BitsT', bound = _Bits)
_T_cov = TypeVar('_T_cov', covariant = True, bound = HardwareDataType)
_T_contra = TypeVar('_T_contra', contravariant = True, bound = HardwareDataType)

DataType = Union[ Wire[_T], InPort[_T], OutPort[_T], _T, Expr[_T] ]
Signal = Union[ Wire[_T], InPort[_T], OutPort[_T] ]
ConnectableType = Union[ Wire[_T], InPort[_T], OutPort[_T] ]

# Coercive types: supports for static duck typing

# class Signal( Generic[_T] ):
  # def __get__( s, obj: Optional[Component], ty: Type[Component] ) -> _T: ...

# class CoerciveWire( Protocol, Generic[_T] ):
class Assignable( Generic[_T] ):
  @overload
  def __set__( s, obj: Optional[Component], value: Expr[_T] ) -> None: ...

  @overload
  def __set__( s, obj: Optional[Component], value: _T ) -> None: ...

# class CoerciveOutPort( Protocol, Generic[_T] ):
  # @overload
  # def __set__( s, obj: Optional[Component], value: Expr[_T] ) -> None: ...

  # @overload
  # def __set__( s, obj: Optional[Component], value: _T,) -> None: ...

class Component:

  # __init__ and construct are not annotated because they are dynamically
  # typed. Users are responsible for supplying type annotations for
  # BOTH __init__ and construct.

  # Construction time APIs

  # Note:
  # mypy unification does not work correctly if we have the following
  #   ConnectableType = Union[ _T, Wire[_T], InPort[_T], OutPort[_T] ]
  # The above definition is wrong because we don't want to connect two
  # constants together. So this does not do much harm here but it's worth
  # noting the fact that some types fail to unify in mypy.

  @overload
  def connect( s, u: _T, v: ConnectableType[_T] ) -> None: ...

  @overload
  def connect( s, u: ConnectableType[_T], v: _T ) -> None: ...

  @overload
  def connect( s, u: ConnectableType[_T], v: ConnectableType[_T] ) -> None: ...

  def update( s, func: Callable[[], None] ) -> Callable[[], None]: ...

  def update_on_edge( s, func: Callable[[], None] ) -> Callable[[], None]: ...

  # Post-construction APIs

  def elaborate( s ) -> None: ...

class Expr( Generic[_T] ): ...
# class Expr( Generic[_AnyBits] ):
  # def __add__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __and__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __or__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __xor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  # def __radd__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rand__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __ror__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rxor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  # def __getitem__( s, index: NumericalValueType ) -> Expr[Bits1]: ...
  # def __getitem__( s, index: Union[int, Expr[_AnyBits]] ) -> Expr[Bits1]: ...

class Const( Expr[_T] ):
# class Const( Expr[_T], Generic[_T] ):
# class Const( Signal[_T], Generic[_T] ):
  # def __init__( s, other: NumericalValueType[_T] ) -> None: ...
  def __init__( s, other: NumericalValueType ) -> None: ...
  # def __init__( s, other: int ) -> None: ...

  def __add__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __and__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __or__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __xor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  def __radd__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rand__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __ror__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rxor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  # def __getitem__( s, index: NumericalValueType ) -> Expr[Bits1]: ...
  def __getitem__( s: Expr[_AnyBits], index: Union[int, Expr[_AnyBits]] ) -> Expr[Bits1]: ...

class Wire( Expr[_T] ):
# class Wire( Expr[_T], Assignable[_T], Generic[_T] ):
# class Wire( Signal[_T], Assignable[_T], Generic[_T] ):
  def __init__( s, Type: Optional[HardwareMetaDataType] = ... ) -> None: ...

  def __add__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __and__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __or__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __xor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  def __radd__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rand__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __ror__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rxor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  # def __getitem__( s, index: NumericalValueType ) -> Wire[Bits1]: ...
  def __getitem__( s: Expr[_AnyBits], index: Union[int, Expr[_AnyBits]] ) -> Expr[Bits1]: ...

class InPort( Expr[_T] ):
# class InPort( Expr[_T], Generic[_T] ):
# class InPort( Signal[_T], Generic[_T] ):
  def __init__( s, Type: Optional[HardwareMetaDataType] = ... ) -> None: ...

  # def __add__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  def __add__( s: Expr[_T], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __and__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __or__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __xor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  def __radd__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rand__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __ror__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rxor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  # def __getitem__( s, index: NumericalValueType ) -> Wire[Bits1]: ...
  def __getitem__( s: Expr[_AnyBits], index: Union[int, Expr[_AnyBits]] ) -> Expr[Bits1]: ...

class OutPort( Expr[_T], Assignable[_T] ):
# class OutPort( Expr[_T], Assignable[_T], Generic[_T] ):
# class OutPort( Signal[_T], Assignable[_T], Generic[_T] ):
  def __init__( s, Type: Optional[HardwareMetaDataType] = ... ) -> None: ...

  def __add__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __and__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __or__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __xor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  def __radd__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rand__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __ror__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...
  # def __rxor__( s: Expr[_AnyBits], other: Expr[_AnyBits] ) -> Expr[_AnyBits]: ...

  # def __getitem__( s, index: NumericalValueType ) -> Wire[Bits1]: ...
  def __getitem__( s: Expr[_AnyBits], index: Union[int, Expr[_AnyBits]] ) -> Expr[Bits1]: ...
