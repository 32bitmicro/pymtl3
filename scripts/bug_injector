#!/usr/bin/env python
#=========================================================================
# bug_injector.py
#=========================================================================
# A bug injector that recognizes and mutates PyMTL-specific Python AST.
#
# A typical work flow of the injector is as follows:
# 1. The injector takes a json file that specifies a list of target files.
# 2. The injector randomly mutates one file in the list IN PLACE.
# 3. Top level script calls type checking / simulation.
# 4. Use `git reset --hard` to discard the bug injected file.
#
# It's important to have your working directory clean before invoking the
# bug injector, which makes automated testing possbile.
#
# Author : Peitian Pan
# Date:    Nov 7, 2019

import ast
import astunparse
import argparse
import json
import os
from contextlib import contextmanager
from copy import deepcopy
from random import randint, sample

BUG_BITWIDTH  = 0
BUG_COMP_ATTR = 1
BUG_PORT_DIR  = 2
BUG_NAME_EXPR = 3
BUG_ATTR_BASE = 4
BUG_FUNCT     = 5
BUG_SENTINEL  = 6
BUGS = range(BUG_SENTINEL)
BUG_STR = {
    BUG_BITWIDTH  : 'bit width mutation',
    BUG_COMP_ATTR : 'component attribute name mutation',
    BUG_PORT_DIR  : 'port direction mutation',
    BUG_NAME_EXPR : 'name expression mutation',
    BUG_ATTR_BASE : 'attribute base mutation',
    BUG_FUNCT     : 'functional behavior mutation',
}

SAMPLE_THRESHOLD = 30
# SAMPLE_THRESHOLD = 100


#-------------------------------------------------------------------------
# Helper functions and classes
#-------------------------------------------------------------------------

def parse_cmdline():
  p = argparse.ArgumentParser()
  p.add_argument( "--input-spec" )
  p.add_argument( "--verbose",      action = 'store_true', default = False )
  p.add_argument( "--mode",         choices = ['random', 'profile', 'precise'], default = 'random' )
  p.add_argument( "--candidate-dir" )
  p.add_argument( "--no-overwrite", action = 'store_true', default = False )
  p.add_argument( "--functional",   action = 'store_true', default = False )

  opts = p.parse_args()
  return opts


class TargetExtractor( ast.NodeVisitor ):

  def __init__( s ):
    s.ctxt = BugInjectionContext()
    s.mutation_targets = []
    super().__init__()

  def visit_ClassDef( s, node ):
    with enter_ctxt(s.ctxt, node):
      for stmt in node.body:
        s.visit(stmt)

  def visit_FunctionDef( s, node ):
    if node.name == 'line_trace':
      # Nothing to look at inside the line trace method
      return
    with enter_ctxt(s.ctxt, node):
      for stmt in node.body:
        s.visit(stmt)


class BugInjectionContext:

  def __init__( s ):
    s.all_ctxt = []

  def push( s, node ):
    s._check_valid_context(node)
    s.all_ctxt.append(node)

  def pop( s ):
    assert len(s.all_ctxt) > 0
    s.all_ctxt.pop()

  def _check_valid_context( s, node ):
    assert isinstance(node, (ast.ClassDef, ast.FunctionDef))
    if isinstance(node, ast.ClassDef):
      assert len(s.all_ctxt) == 0
    elif isinstance(node, ast.FunctionDef):
      if node.name == 'construct':
        assert s.is_cur_component()
      else:
        # Take it as update block
        assert s.is_cur_construct()
    else:
      raise AssertionError

  def is_cur_component( s ):
    return len(s.all_ctxt) > 0 and \
           isinstance(s.all_ctxt[-1], ast.ClassDef) and \
           isinstance(s.all_ctxt[-1].bases[0], ast.Name) and \
           s.all_ctxt[-1].bases[0].id == 'Component'

  def is_cur_inside_construct( s ):
    return s.is_cur_construct() or s.is_cur_upblk()

  def is_cur_construct( s ):
    return len(s.all_ctxt) > 0 and \
           isinstance(s.all_ctxt[-1], ast.FunctionDef) and \
           s.all_ctxt[-1].name == 'construct'

  def is_cur_upblk( s ):
    return len(s.all_ctxt) > 0 and \
           isinstance(s.all_ctxt[-1], ast.FunctionDef) and \
           s.all_ctxt[-1].name != 'construct'


@contextmanager
def enter_ctxt( ctxt, node ):
  ctxt.push(node)
  yield ctxt
  ctxt.pop()


#-------------------------------------------------------------------------
# Bit width mutation
#-------------------------------------------------------------------------
# Randomly find and mutate an occurrence of BitsN inside construct to a
# different bit width.

class BitwidthTargetExtractor( TargetExtractor ):

  def is_int( s, name ):
    try:
      int(name)
      return True
    except ValueError:
      return False

  def is_target( s, name ):
    if not s.ctxt.is_cur_inside_construct():
      return False
    if name.startswith('Bits') and s.is_int(name[4:]):
      return True
    elif name.startswith('b') and s.is_int(name[1:]):
      return True
    return False

  def visit_Name( s, node ):
    name = node.id
    if s.is_target(name):
      s.mutation_targets.append(node)


def mutate_bitwidth(r, mode, status):
  extractor = BitwidthTargetExtractor()
  extractor.visit(r)
  targets = extractor.mutation_targets

  if mode == 'profile':
    return targets

  if not targets:
    assert mode != 'precise', 'Wrong bug kind generated!'
    return False, 0, 0

  # Randomly pick one target to mutate
  if mode == 'random' or (mode == 'precise' and len(targets) > SAMPLE_THRESHOLD):
    target = targets[randint(0, len(targets)-1)]
  # Use the chosen bug
  elif mode == 'precise':
    index = status['current_primary_candidate_bug_index']
    target = targets[index]
    status['current_primary_candidate_bug_index'] += 1

  # Get new BitsN
  if target.id.startswith('Bits'):
    _N = int(target.id[4:])
  else:
    _N = int(target.id[1:])
  N = _N+1

  # Mutate
  target.id = 'Bits' + str(N)
  
  print(f"Bits{_N} -> Bits{N}")

  return True, target.lineno, target.col_offset


#-------------------------------------------------------------------------
# Component attribute mutation
#-------------------------------------------------------------------------
# Randomly find and mutate an occurrence of `s.xxxxx` to a different
# attribute.

class CompAttrTargetExtractor( TargetExtractor ):

  def is_target( s, node ):
    if not s.ctxt.is_cur_inside_construct():
      return False
    # check for s.
    base = node.value
    if not isinstance(base, ast.Name) or base.id != 's':
      return False
    return True

  def visit_Attribute( s, node ):
    # this visit will only be called on the top level attribute
    if s.is_target(node):
      s.mutation_targets.append(node)

def mutate_comp_attr(r, mode, status):

  def num_candidate_bugs(targets):
    ret = 0
    for t in targets:
      for s in targets:
        if t.attr != s.attr:
          ret += 1
    return ret

  extractor = CompAttrTargetExtractor()
  extractor.visit(r)
  targets = extractor.mutation_targets

  if mode == 'profile':
    return targets

  if len(targets) < 2:
    assert mode != 'precise', 'Wrong bug kind generated!'
    return False, 0, 0

  # Sample two targets; change the attr of first target to attr of the second
  if mode == 'random' or (mode == 'precise' and num_candidate_bugs(targets) > SAMPLE_THRESHOLD):
    while True:
      target, to = sample(targets, 2)
      # If we accidentally ran into two attributes of the same name, re-roll the dice
      # and hope we get different attributes
      if target.attr != to.attr:
        break

  elif mode == 'precise':
    # Use the chosen bug
    l, r = status['current_primary_candidate_bug_index'], status['current_secondary_candidate_bug_index']
    target, to = targets[l], targets[r]
    while l != len(targets):
      found = False
      for _r in range(r+1, len(targets)):
        if targets[l].attr != targets[_r].attr:
          found = True
          break
      if found:
        status['current_primary_candidate_bug_index'] = l
        status['current_secondary_candidate_bug_index'] = _r
        break
      else:
        l += 1

  print(f"s.{target.attr} -> s.{to.attr}")

  # Mutate
  target.attr = to.attr

  return True, target.lineno, target.col_offset


#-------------------------------------------------------------------------
# Port direction mutation
#-------------------------------------------------------------------------
# Randomly find and mutate an InPort or OutPort to have a different
# direction.

class PortDirTargetExtractor( TargetExtractor ):

  def is_target( s, name ):
    if not s.ctxt.is_cur_construct():
      return False
    return name in ('InPort', 'OutPort')

  def visit_Name( s, node ):
    if s.is_target(node.id):
      s.mutation_targets.append(node)

def mutate_port_dir(r, mode, status):
  extractor = PortDirTargetExtractor()
  extractor.visit(r)
  targets = extractor.mutation_targets

  if mode == 'profile':
    return targets

  if not targets:
    assert mode != 'precise', 'Wrong bug kind generated!'
    return False, 0, 0

  # Randomly select a target
  if mode == 'random' or (mode == 'precise' and len(targets) > SAMPLE_THRESHOLD):
    target = targets[randint(0, len(targets)-1)]
  elif mode == 'precise':
    index = status['current_primary_candidate_bug_index']
    target = targets[index]
    status['current_primary_candidate_bug_index'] += 1

  print(f"{target.id} will be flipped")

  # Mutate
  if target.id == "InPort":
    target.id = "OutPort"
  else:
    target.id = "InPort"

  return True, target.lineno, target.col_offset


#-------------------------------------------------------------------------
# Name expression mutation
#-------------------------------------------------------------------------
# Randomly find and mutate a name expression that does not contain PyMTL
# keywords to a different name expression.

class NameExprTargetExtractor( TargetExtractor ):

  pymtl_keywords = [
      'InPort', 'OutPort', 'Wire', 'Component', 'Const',
      'RoundRobinArbiter', 'RoundRobinArbiterEn',
      'Crossbar', 'RegisterFile',
      'Adder', 'And', 'Incrementer', 'LEComp', 'LTComp', 'ZeroComp',
      'Reg', 'RegEn', 'RegEnRst', 'RegRst', 'Mux', 'RShifter', 'LShifter', 'Subtractor',
      'InValRdyIfc', 'OutValRdyIfc',
      'BypassQueue1RTL', 'NormalQueue1RTL', 'NormalQueueRTL', 'PipeQueue1RTL',
      'MemoryFL', 'MemoryCL', 'PipeQueueCL',
      'DeqIfcRTL', 'EnqIfcRTL', 'GetIfcRTL', 'GiveIfcRTL',
      'MemMsgType', 'XcelMsgType',
      'RecvCL2SendRTL', 'RecvIfcRTL', 'RecvRTL2SendCL', 'SendIfcRTL',
  ]

  def __init__( s ):
    s.name_mapping = {}
    super().__init__()

  def has_mapping( s, name ):
    return name in s.name_mapping

  def get_mapping( s, name ):
    return s.name_mapping[name]

  def update_mapping( s, name, value ):
    s.name_mapping[name] = value

  def get_all_mapping_values( s ):
    return list(s.name_mapping.values())

  def is_reserved( s, name ):
    if name.startswith('Bits'):
      return True
    return name in s.pymtl_keywords

  def is_target( s, name ):
    if not s.ctxt.is_cur_inside_construct():
      return False
    return name[0].isupper() and not s.is_reserved(name) and \
           (not s.has_mapping(name) or s.get_mapping(name) not in s.get_all_mapping_values())

  def visit_Assign( s, node ):
    if len(node.targets) == 1 and isinstance(node.targets[0], ast.Name) and \
       isinstance(node.value, ast.Num):
      s.update_mapping(node.targets[0].id, node.value.n)
    for target in node.targets:
      s.visit(target)
    s.visit(node.value)

  def visit_Name( s, node ):
    if s.is_target(node.id) and node.id not in [node.id for node in s.mutation_targets]:
      s.mutation_targets.append(node)

def mutate_name_expr(r, mode, status):
  extractor = NameExprTargetExtractor()
  extractor.visit(r)
  targets = extractor.mutation_targets

  if mode == 'profile':
    return targets

  if len(targets) < 2:
    assert mode != 'precise', 'Wrong bug kind generated!'
    return False, 0, 0

  # Sample two targets and change the name of the first to name of the second
  if mode == 'random' or (mode == 'precise' and len(targets)*(len(targets)-1) > SAMPLE_THRESHOLD):
    target, to = sample(targets, 2)
  elif mode == 'precise':
    l, r = status['current_primary_candidate_bug_index'], status['current_secondary_candidate_bug_index']
    if r == l:
      r += 1
      if r == len(targets):
        l += 1
        r = 0
        print("bug injector: name expression bug injection out of bound!")
    target, to = targets[l], targets[r]
    r += 1
    if r == len(targets):
      r = 0
      l += 1
    status['current_primary_candidate_bug_index']   = l
    status['current_secondary_candidate_bug_index'] = r

  print(f"{target.id} -> {to.id}")

  # Mutate
  target.id = to.id

  return True, target.lineno, target.col_offset


#-------------------------------------------------------------------------
# Attribute base mutation
#-------------------------------------------------------------------------
# Randomly find and mutate a `s.xxxxxx` to `xxxxxx`.

class AttrBaseTargetExtractor( TargetExtractor ):

  def is_target( s, node ):
    if not s.ctxt.is_cur_inside_construct() or not isinstance(node, ast.Attribute):
      return False
    # check for s.
    base = node.value
    if not isinstance(base, ast.Name) or base.id != 's':
      return False
    return True

  def visit_Assign( s, node ):
    if len(node.targets) == 1:
      if s.is_target(node.targets[0]):
        s.mutation_targets.append((node, 'L'))
      if s.is_target(node.value):
        s.mutation_targets.append((node, 'R'))

def mutate_attr_base(r, mode, status):
  extractor = AttrBaseTargetExtractor()
  extractor.visit(r)
  targets = extractor.mutation_targets

  if mode == 'profile':
    return targets

  if not targets:
    assert mode != 'precise', 'Wrong bug kind generated!'
    return False, 0, 0

  # Randomly pick one target
  if mode == 'random' or (mode == 'precise' and len(targets) > SAMPLE_THRESHOLD):
    target, side = targets[randint(0, len(targets)-1)]
  elif mode == 'precise':
    index = status['current_primary_candidate_bug_index']
    target, side = targets[index]
    status['current_primary_candidate_bug_index'] += 1

  # Mutate
  if side == 'L':
    print(f"s.{target.targets[0].attr} -> {target.targets[0].attr}")
    target.targets[0] = ast.Name(id=target.targets[0].attr, ctx=ast.Store())
  elif side == 'R':
    print(f"s.{target.value.attr} -> {target.value.attr}")
    target.value = ast.Name(id=target.value.attr, ctx=ast.Load())

  return True, target.lineno, target.col_offset


#-------------------------------------------------------------------------
# Functional mutation
#-------------------------------------------------------------------------
# Randomly find and mutate a constant number or operator

class FunctionalTargetExtractor( TargetExtractor ):

  def is_target( s, node ):
    if not s.ctxt.is_cur_upblk(): return False
    if isinstance( node, ast.Num ) or isinstance( node, ast.BoolOp ) or \
       isinstance( node, ast.BinOp ) or isinstance( node, ast.Compare ):
      return True
    return False

  def visit_Num( s, node ):
    if s.is_target( node ):
      s.mutation_targets.append((node, 'number'))

  def visit_BoolOp( s, node ):
    if s.is_target( node ):
      s.mutation_targets.append((node, 'bool'))
    for value in node.values:
      s.visit(value)

  def visit_BinOp( s, node ):
    if s.is_target( node ):
      s.mutation_targets.append((node, 'bin'))
    s.visit(node.left)
    s.visit(node.right)

  def visit_Compare( s, node ):
    if s.is_target( node ):
      s.mutation_targets.append((node, 'cmp'))
    s.visit(node.left)
    s.visit(node.comparators[0])

def new_bool_op( op ):
  m = { ast.And : ast.Or, ast.Or : ast.And }
  return m[op.__class__]

def new_bin_op( op ):
  m = { ast.Add : ast.Sub, ast.Sub : ast.Add,
        ast.Mult : ast.Add, ast.Div : ast.Sub,
        ast.LShift : ast.RShift, ast.RShift : ast.LShift,
        ast.BitOr : ast.BitAnd, ast.BitAnd : ast.BitOr,
        ast.BitXor : ast.BitOr,
      }
  return m[op.__class__]

def new_cmp_op( op ):
  m = { ast.Eq : ast.NotEq, ast.NotEq : ast.Eq,
        ast.Lt : ast.Gt, ast.LtE : ast.GtE,
        ast.Gt : ast.Lt, ast.GtE : ast.LtE,
      }
  return m[op.__class__]

def mutate_funct(r, mode, status):
  extractor = FunctionalTargetExtractor()
  extractor.visit(r)
  targets = extractor.mutation_targets

  if mode == 'profile':
    return targets

  if not targets:
    assert mode != 'precise', 'Wrong bug kind generated!'
    return False, 0, 0

  # Randomly pick one target
  if mode == 'random' or (mode == 'precise' and len(targets) > SAMPLE_THRESHOLD):
    target, kind = targets[randint(0, len(targets)-1)]
  elif mode == 'precise':
    index = status['current_primary_candidate_bug_index']
    target, kind = targets[index]
    status['current_primary_candidate_bug_index'] += 1

  # Mutate
  if kind == 'number':
    print(f"{target.n} -> {target.n + 1}")
    target.n = target.n + 1
  elif kind == 'bool':
    res = new_bool_op(target.op) 
    print(f"{target.op.__class__} -> {res}")
    target.op = res()
  elif kind == 'bin':
    res = new_bin_op(target.op)
    print(f"{target.op.__class__} -> {res}")
    target.op = res()
  elif kind == 'cmp':
    res = new_cmp_op(target.ops[0])
    print(f"{target.ops[0].__class__} -> {res}")
    target.ops[0] = res()
  else:
    raise AssertionError

  return True, target.lineno, target.col_offset


BUG_HANDLERS =  {
    BUG_BITWIDTH  : mutate_bitwidth,
    BUG_COMP_ATTR : mutate_comp_attr,
    BUG_PORT_DIR  : mutate_port_dir,
    BUG_NAME_EXPR : mutate_name_expr,
    BUG_ATTR_BASE : mutate_attr_base,
    BUG_FUNCT     : mutate_funct,
}


# Mutate the AST located in r
def mutate(r, bug, mode = 'random', status = None):
  assert bug in BUG_HANDLERS
  # import pdb
  # pdb.set_trace()
  return BUG_HANDLERS[bug](r, mode, status)


def print_mutation(bug, target, targets, tree, lineno, col, opts):
  print(f"Chose to mutate {target} out of {len(targets)} targets")
  print(f"Bug chosen: {BUG_STR[bug]}")
  print(f"Mutation happened on line {lineno}, col {col}. Original line:")
  print(f"{target_lines[lineno-1]}")
  print()

  # Write mutated source code to a temporary file
  with open( target + ".tmp", "w" ) as fd:
    fd.write(astunparse.unparse(tree))

  # Rename the tmp file to overwrite the target
  if not opts.no_overwrite:
    os.rename( target + ".tmp", target )


def read_target(target):
  with open(target, 'r') as fd:
    tree = ast.parse(fd.read())
    fd.seek(0, 0)
    target_lines = fd.readlines()
  return tree, target_lines


def has_no_bugs(bug_count):
  return sum(bug_count.values()) == 0


if __name__ == "__main__":
  n_tried = 0
  opts = parse_cmdline()
  print("===============================")

  # Load the target files
  with open( opts.input_spec, "r" ) as fd:
    targets = json.load(fd)

  # Profiling mode
  if opts.mode == 'profile':
    bug_count = {val : 0 for val in BUG_STR.keys()}
    bug_file_count = {filename : {bug : 0 for bug in BUG_STR.keys()} for filename in targets}
    for target in targets:
      # For each target, count the number of unique bugs the injector
      # is able to introduce
      tree, target_lines = read_target(target)

      for bug in BUG_STR.keys():
        candidate_bugs = mutate(tree, bug, opts.mode)
        # if opts.verbose:
        if bug in (BUG_BITWIDTH, BUG_PORT_DIR, BUG_ATTR_BASE, BUG_FUNCT):
          n = len(candidate_bugs)
        elif bug == BUG_NAME_EXPR:
          n = len(candidate_bugs) * (len(candidate_bugs) - 1)
        elif bug == BUG_COMP_ATTR:
          n = 0
          for c in candidate_bugs:
            for _c in candidate_bugs:
              if c.attr != _c.attr:
                n += 1
        print(f"Bug `{BUG_STR[bug]}` on file `{target}` has {len(candidate_bugs)} candidates, {n} candidate bugs")
        bug_count[bug] += n
        bug_file_count[target][bug] = n
    print()
    for bug in BUG_STR.keys():
      print(f"Bug `{BUG_STR[bug]}` has {bug_count[bug]} candidate bugs")

    # Create an initial status under --candidate-dir
    status = {
        'current_file_index' : 0,
        'current_bug_kind' : BUG_BITWIDTH,
        'current_primary_candidate_bug_index' : 0,
        'current_secondary_candidate_bug_index' : 0,
        'current_finished_bugs' : 0,
        'current_file_finished_bugs' : 0,
        'design_bug_count' : bug_file_count,
    }
    status_path = opts.candidate_dir+'/injector_status'
    with open(status_path, 'w') as fd:
      json.dump(status, fd, indent=4)

  # Random mode
  elif opts.mode == 'random':
    # Loop until a valid bug is generated
    while True:
      if n_tried > 100:
        print(f"Failed to produce a bug after 100 trials!")
        break

      target = targets[randint(0, len(targets)-1)]
      tree, target_lines = read_target(target)

      if opts.functional:
        bug = BUG_FUNCT
      else:
        # Randomly pick a bug
        bug = randint(0, BUG_SENTINEL-1)

      # bug = BUG_BITWIDTH
      # bug = BUG_COMP_ATTR
      # bug = BUG_PORT_DIR
      # bug = BUG_NAME_EXPR
      # bug = BUG_ATTR_BASE
      # bug = BUG_FUNCT

      # Mutation here
      done, lineno, col = mutate(tree, bug)

      if done:
        print_mutation(bug, target, targets, tree, lineno, col, opts)
        break

      n_tried += 1

  # Precise mode
  elif opts.mode == 'precise':
    # Load status from injector status file
    status_path = opts.candidate_dir+'/injector_status'
    with open(status_path, 'r') as fd:
      status = json.load(fd)

    # Load the correct file
    cur_file_index = status['current_file_index']
    target = targets[cur_file_index]
    tree, target_lines = read_target(target)

    # Mutate
    done, lineno, col = mutate(tree, status['current_bug_kind'], 'precise', status)
    print_mutation(status['current_bug_kind'], target, targets, tree, lineno, col, opts)

    # Prepare status for the next bug injection
    status['current_finished_bugs'] += 1
    bug = status['current_bug_kind']
    cur_file_bug_count = status['design_bug_count'][target][str(bug)]
    cur_file_finished_bugs = status['current_file_finished_bugs']
    cur_file_finished_bugs += 1

    # All bugs for the current kind have finished
    if cur_file_finished_bugs == cur_file_bug_count or \
       (cur_file_bug_count > SAMPLE_THRESHOLD and cur_file_finished_bugs == SAMPLE_THRESHOLD):
      # Move to the next kind of bugs
      bug = bug + 1
      while bug != BUG_SENTINEL and status['design_bug_count'][target][str(bug)] == 0:
        bug = bug + 1

      # All kinds of bugs for the current file have finished
      if bug == BUG_SENTINEL:
        # Move to the next file
        cur_file_index += 1
        while cur_file_index != len(targets) and has_no_bugs(status['design_bug_count'][targets[cur_file_index]]):
          cur_file_index += 1

        if cur_file_index == len(targets):
          # All files finished
          print('==================Bug injection finished==================')
        else:
          # Move to the next file
          status['current_file_index'] = cur_file_index
          status['current_bug_kind'] = int(next(filter(lambda x: x[1] != 0,
                                              status['design_bug_count'][targets[cur_file_index]].items())))
          status['current_primary_candidate_bug_index'] = 0
          status['current_secondary_candidate_bug_index'] = 0
          status['current_file_finished_bugs'] = 0

      else:
        # Move to the next kind of bugs
        status['current_bug_kind'] = bug
        status['current_primary_candidate_bug_index'] = 0
        status['current_secondary_candidate_bug_index'] = 0
        status['current_file_finished_bugs'] = 0
    else:
      # Move to the next bug in the current kind
      status['current_file_finished_bugs'] += 1

    # Dump out the current status
    with open(status_path, 'w') as fd:
      json.dump(status, fd, indent=4)

  else:
    raise AssertionError
