#=========================================================================
# OpenLoopCLPass.py
#=========================================================================
# Generate a simple schedule (no Mamba techniques here) based on the
# DAG generated by some previous pass.
#
# Author : Shunning Jiang
# Date   : Apr 20, 2019

from BasePass     import BasePass, PassMetadata
from collections  import deque
from graphviz     import Digraph
from errors import PassOrderError
from pymtl.dsl.errors import UpblkCyclicError
from pymtl import *

class OpenLoopCLPass( BasePass ):
  def __call__( self, top ):
    if not hasattr( top._dag, "all_constraints" ):
      raise PassOrderError( "all_constraints" )

    top._sched = PassMetadata()

    self.schedule_with_top_level_callee( top )

  def schedule_with_top_level_callee( self, top ):

    # Construct the graph with top level callee port

    V   = top.get_all_update_blocks() | top._dag.genblks | top._dag.top_level_callee_ports
    E   = top._dag.all_constraints | top._dag.top_level_callee_constraints
    Es  = { v: [] for v in V }
    InD = { v: 0  for v in V }

    for (u, v) in E: # u -> v
      InD[v] += 1
      Es [u].append( v )

    # Perform topological sort for a serial schedule.

    schedule = []

    Q = deque( [ v for v in V if not InD[v] ] )

    while Q:
      import random
      random.shuffle(Q)
      u = Q.pop()
      schedule.append( u )
      for v in Es[u]:
        InD[v] -= 1
        if not InD[v]:
          Q.append( v )

    top._sched.schedule_execute_index = 0

    def wrap_method( top, my_idx, next_idx, schedule_no_method, method ):

      def actual_method( *args, **kwargs ):
        i = top._sched.schedule_execute_index

        if i > my_idx:
          # This means we need to advance the current cycle to the end
          # and then normally execute until we get to the same point
          while i < len(schedule_no_method):
            schedule_no_method[i]()
            i += 1
          i = 0

        # We advance from the current point i to the method's position in
        # the schedule without method just to execute those blocks
        while i < my_idx:
          schedule_no_method[i]()
          i += 1

        # Execute the method
        ret = method( *args, **kwargs )

        # Execute all update blocks before the next method. Note that if
        # there are several consecutive methods, my_idx is equal to next_idx
        while i < next_idx:
          schedule_no_method[i]()
          i += 1

        if i == len(schedule_no_method):
          i = 0

        top._sched.schedule_execute_index = i
        return ret

      return actual_method

    # Here we are trying to avoid scanning the original schedule that
    # contains methods because we will need isinstance in that case.
    # As a result we created a preprocessed list for execution and use
    # the dictionary to look up the new index of functions.

    # The last element is always line trace
    def print_line_trace():
      print top.line_trace()
    schedule.append( print_line_trace )

    schedule_no_method = [ x for x in schedule if not isinstance(x, CalleePort) ]
    mapping = { x : i for i, x in enumerate( schedule_no_method ) }

    for i, x in enumerate( schedule ):
      if isinstance( x, CalleePort ):
        x.original_method = x.method

        # This is to find the next non-method block's position in the
        # original schedule
        next_func   = i + 1
        while next_func < len(schedule):
          if not isinstance( schedule[next_func], CalleePort ):
            break
          next_func += 1

        # Get the index of the block in the schedule without method
        # This always exists because we append a line trace at the end
        map_next_func = mapping[ schedule[next_func] ]

        # Get the index of the next method in the schedule without method
        next_method = i + 1
        while next_method < len(schedule):
          if isinstance( schedule[next_method], CalleePort ):
            break
          next_method += 1

        # If there is another method after me, I calculate the range of
        # blocks that I need to call and then stop before the user calls
        # the next method.
        if next_method < len(schedule):
          next_func = next_method
          while next_func < len(schedule):
            if not isinstance( schedule[next_func], CalleePort ):
              break
            next_func += 1
          # Get the index in the compacted schedule
          map_next_func_of_next_method = mapping[ schedule[next_func] ]
        else:
          map_next_func_of_next_method = len(schedule_no_method)

        x.method = wrap_method( top,
                                map_next_func,
                                map_next_func_of_next_method,
                                schedule_no_method,
                                x.method )

    #  from graphviz import Digraph
    #  dot = Digraph()
    #  dot.graph_attr["rank"] = "same"
    #  dot.graph_attr["ratio"] = "compress"
    #  dot.graph_attr["margin"] = "0.1"

    #  for x in V:
      #  x_name = repr(x) if isinstance( x, CalleePort ) else x.__name__
      #  x_host = repr(x.get_parent_object() if isinstance( x, CalleePort )
                    #  else top.get_update_block_host_component(x))
      #  dot.node( x_name +"\\n@" + x_host, shape="box")

    #  for (x, y) in E:
      #  x_name = repr(x) if isinstance( x, CalleePort ) else x.__name__
      #  x_host = repr(x.get_parent_object() if isinstance( x, CalleePort )
                    #  else top.get_update_block_host_component(x))
      #  y_name = repr(y) if isinstance( y, CalleePort ) else y.__name__
      #  y_host = repr(y.get_parent_object() if isinstance( y, CalleePort )
                    #  else top.get_update_block_host_component(y))

      #  dot.edge( x_name+"\\n@"+x_host, y_name+"\\n@"+y_host )
    #  dot.render( "/tmp/upblk-dag.gv", view=True )

    return schedule

