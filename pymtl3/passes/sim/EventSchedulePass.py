"""
========================================================================
EventSchedulePass.py
========================================================================
Generate a simple schedule (no Mamba techniques here) based on the
DAG generated by some previous pass.

Author : Shunning Jiang
Date   : Dec 8, 2020
"""
import linecache, py, time
from collections import defaultdict
from heapq import heappush, heappop

from pymtl3.dsl.Component import Component
from pymtl3.dsl.NamedObject import NamedObject
from pymtl3.dsl.Connectable import Const, Interface, MethodPort, Signal
from pymtl3.dsl.errors import UpblkCyclicError
from pymtl3.extra.pypy import custom_exec
from pymtl3.passes.BasePass import BasePass, PassMetadata
from pymtl3.passes.errors import PassOrderError

"""
Delays can also be specified within an assignment statement as in

  p = #10 (a | b); // Example of intra-assignment delay

This statement is interpreted as follows
- First evaluate the right hand expression (a | b). Then wait for 10 units of time.
After this wait, assign the value of RHS to LHS. The above is called intra assignment delay. The above statement is equivalent to

  temp = (a | b); // evaluate the RHS and hold it temporarily
  #10; // Wait for 10 units of time
  p = temp; // Assign the temporary evaluation to LHS

"""

class EventSchedulePass( BasePass ):
  def __call__( self, top ):
    if not hasattr( top._dag, "all_constraints" ):
      raise PassOrderError( "all_constraints" )

    top._sched = PassMetadata()

    self.replace_signals_with_value( top )
    self.create_check_top_level_inports( top )
    self.schedule( top )

  def create_check_top_level_inports( self, top ):
    # Check top level input ports are invoked with @=
    inports = []
    objs    = []
    for x in top._dsl.all_signals:
      if x.is_input_value_port() and x.is_top_level_signal() and x.get_host_component() is top:
        inports.append( x )
        objs.append( top._sched.signal_object_mapping[x][-1] )

    src = """
def check_top_level_inports():
  {}
""".format( "\n  ".join([ f"assert {x} is obj{i}, 'Please use @= to assign top level InPort top.{repr(x)[2:]}'"
                          for i, x in enumerate(inports) ]) )
    _locals = {}
    _globals = { f"obj{i}" : x for i, x in enumerate(objs) }
    _globals['s'] = top
    custom_exec( py.code.Source(src).compile(), _globals, _locals)
    top._check_top_level_inports = _locals['check_top_level_inports']

  def replace_signals_with_value( self, top ):

    signal_object_mapping = {}

    Q = [ (top, top) ]
    while Q:
      current_obj, host = Q.pop()
      if isinstance( current_obj, list ):
        for i, obj in enumerate( current_obj ):
          if isinstance( obj, Signal ):
            try:
              value = obj.default_value()
              if obj._dsl.needs_double_buffer:
                value <<= value
            except Exception as e:
              raise type(e)(str(e) + f' happens at {obj!r}')

            current_obj[i] = value

            signal_object_mapping[ obj ] = (current_obj, i, True, value)

          elif isinstance( obj, Component ):
            Q.append( (obj, obj) )
          elif isinstance( obj, (Interface, list) ):
            Q.append( (obj, host) )

      elif isinstance( current_obj, NamedObject ):
        for i, obj in current_obj.__dict__.items():
          if i[0] == '_': continue

          if isinstance( obj, Signal ):
            try:
              value = obj.default_value()
              if obj._dsl.needs_double_buffer:
                value <<= value
            except Exception as e:
              raise type(e)(str(e) + f' happens at {obj!r}')

            setattr( current_obj, i, value )
            signal_object_mapping[obj] = (current_obj, i, False, value)

          elif isinstance( obj, Component ):
            Q.append( (obj, obj) )
          elif isinstance( obj, (Interface, list) ):
            Q.append( (obj, host) )

    # Swap all Signal objects with actual data
    for writer, signals in top.get_all_value_nets():
      residence = None
      if isinstance( writer, Const ) or writer.is_top_level_signal():
        residence = writer
      else:
        for x in signals:
          if x.is_top_level_signal():
            residence = x
            break

      if residence is None:
        continue # whole net is slice

      if isinstance( residence, Const ):
        residence_value = residence._dsl.const
      else:
        residence_value = signal_object_mapping[ residence ][-1]

      for x in signals:
        if x is not residence and x.is_top_level_signal():

          current_obj, i, is_list, value = signal_object_mapping[ x ]
          signal_object_mapping[ x ] = (current_obj, i, is_list, residence_value)

          if is_list:
            current_obj[i] = residence_value
          else:
            setattr( current_obj, i, residence_value )

    top._sched.signal_object_mapping = signal_object_mapping


  def schedule( self, top ):

    if not hasattr( top, "_sched" ):
      raise Exception( "Please create top._sched pass metadata namespace first!" )

    #---------------------------------------------------------------------
    # Creating VCD file
    #---------------------------------------------------------------------

    top._vcd = PassMetadata()
    top._vcd.vcd_file = vcd_file = open( str(top.__class__.__name__) + ".vcd", "w" )

    # Print vcd header

    print( "$date\n  {}\n$end\n$version\n  PyMTL 3 (Mamba) Event Schedule Pass\n$end\n"
           "$timescale\n {}\n$end\n".format( time.asctime(), "1ps" ),
           file=vcd_file )

    def _gen_vcd_symbol():
      _codechars = ''.join([chr(i) for i in range(33, 127)])
      _mod       = len(_codechars)
      n = 0
      while True:
        q, r = divmod(n, _mod)
        code = _codechars[r]
        while q > 0:
          q, r = divmod(q, _mod)
          code = _codechars[r] + code
        yield code
        n += 1

    vcd_symbols = _gen_vcd_symbol()

    # Preprocess some metadata

    component_signals = defaultdict(set)

    all_components = set()

    # We only collect top level signals, and squash bitstruct into a long
    # bits object
    for x in top._dsl.all_signals:
      if x.is_top_level_signal():
        host = x.get_host_component()
        component_signals[ host ].add( x )

    # We pre-process all nets in order to remove all sliced wires because
    # they belong to a top level wire and we count that wire

    trimmed_value_nets = []

    # FIXME handle the case where the top level signal is in a value net
    for writer, net in top.get_all_value_nets():
      new_net = []
      for x in net:
        if not isinstance(x, Const) and x.is_top_level_signal():
          new_net.append( x )

      if new_net:
        trimmed_value_nets.append( new_net )

    # Generate symbol for existing nets

    net_symbol_mapping = [ next(vcd_symbols) for x in trimmed_value_nets ]
    signal_net_mapping = {}

    for i in range(len(trimmed_value_nets)):
      for x in trimmed_value_nets[i]:
        signal_net_mapping[x] = i

    # Inner utility function to perform recursive descent of the model.
    # Shunning: I mostly follow v2's implementation

    # Vcd file takes a(0) instead of a[0]
    def vcd_mangle_name( name ):
      # signal names with colons in it silently fail gtkwave
      return name.replace('[','(').replace(']',')').replace(':', '__')

    def recurse_models( m, spaces ):

      # Special case the top level "s" to "top"

      my_name = m.get_field_name()
      if my_name == "s":
        my_name = "top"

      # Create a new scope for this module
      print( f"{spaces}$scope module {vcd_mangle_name(my_name)} $end",
             file=vcd_file )

      m_name = repr(m)

      # Define all signals for this model.
      for signal in component_signals[m]:

        # Multiple signals may be collapsed into a single net in the
        # simulator if they are connected. Generate new vcd symbols per
        # net, not per signal as an optimization.

        if signal in signal_net_mapping:
          net_id = signal_net_mapping[signal]
          symbol = net_symbol_mapping[net_id]
        else:
          # We treat this as a new net

          # This is a signal whose connection is not captured by the
          # global net data structure. This might be a sliced signal or
          # a signal updated in an upblk. Creating a new net for it does
          # not hurt functionality.

          signal_net_mapping[signal] = len(trimmed_value_nets)
          trimmed_value_nets.append( [ signal ] )
          symbol = next(vcd_symbols)
          net_symbol_mapping.append( symbol )

        # This signal can be a part of an interface so we have to
        # "subtract" host component's name from signal's full name
        # to get the actual name like enq.rdy
        # TODO struct
        signal_name = vcd_mangle_name( repr(signal)[ len(m_name)+1: ] )
        print( f"{spaces}  $var reg {signal._dsl.Type.nbits} {symbol} {signal_name} $end",
               file=vcd_file )

      # Recursively visit all submodels.
      for child in m.get_child_components():
        recurse_models( child, spaces+'  ' )

      print( f"{spaces}$upscope $end", file=vcd_file )

    # Begin recursive descent from the top-level model.
    recurse_models( top, '' )
    print(signal_net_mapping, trimmed_value_nets)
    print(len(trimmed_value_nets))

    # Once all models and their signals have been defined, end the
    # definition section of the vcd and print the initial values of all
    # nets in the design.
    print( "$enddefinitions $end\n", file=vcd_file, flush=True )

    net_details = [ ( trimmed_value_nets[i][0], net_symbol_mapping[i] )
                    for i in range(len(trimmed_value_nets)) ]

    last_values = [None for _ in range(len(trimmed_value_nets))]

    # VCD hooks are as follows:
    # - a normal update block updates all writes instantly
    # - a delayed update block updates nothing. Each flip updates the corresponding signals

    event_vcd_netids = {}
    event_created = set()

    # this is to wrap the bits with a call to the _flip method, as directly
    # referring to the bounded method results in the same handle to the method object
    def create_flip_event( signal_bits ):
      def flip_event():
        return signal_bits._flip()
      return flip_event

    signal_flip_mapping = {}

    for b, writes in top._dsl.all_upblk_writes.items():
      if b in top._dsl.all_update_delay:
        for w in writes:
          signal_flip_mapping[w] = flip_event = create_flip_event( top._sched.signal_object_mapping[w][-1] )

          if w not in event_created:
            event_created.add( w )
            event_vcd_netids[ flip_event ] = [ signal_net_mapping[ w ] ]

      else: # b not in top._dsl.all_update_delay:
        event_vcd_netids[ b ] = netids = []
        for w in writes:
          netids.append( signal_net_mapping[ w ] )

    def create_dump_vcd( s ):
      dump_vcd_file = top._vcd.vcd_file

      def dump_vcd( timestamp, event ):
        nonlocal s
        if event not in event_vcd_netids:
          return

        for netid in event_vcd_netids[ event ]:
          signal, symbol = net_details[netid]
          try:
            net_bits_bin = eval(repr(signal),locals()).to_bits()
          except Exception as e:
            raise TypeError(f'{e}\n - {signal} becomes another type. Please check your code.')

          net_bits_bin_str = net_bits_bin.bin()
          # `last_value` is the string form of a Bits object in binary
          # e.g. '0b000' == Bits3(0).bin()
          # We store strings instead of values ...
          if last_values[netid] != net_bits_bin_str:
            last_values[netid] = net_bits_bin_str
          print( f'#{timestamp}\nb{net_bits_bin_str} {symbol}', file=dump_vcd_file )

      return dump_vcd

    #---------------------------------------------------------------------
    # Event-driven scheduling
    #---------------------------------------------------------------------

    # We already replace signals with variables, as we need to get the handle
    # of x._flip() of the real values

    assert not top.get_all_update_ff()
    V = top._dag.final_upblks

    triggers = { v: [] for v in V }
    preamble = []
    inport_vcds = []

    for b, writes in top._dsl.all_upblk_writes.items():
      if b in top._dsl.all_update_delay:
        delay = top._dsl.all_update_delay[b]
        for w in writes:
          triggers[b].append( ( 0, delay, signal_flip_mapping[w]) )

    for b, reads in top._dsl.all_upblk_reads.items():
      delay = top._dsl.all_update_delay.get( b, 0 )

      for r in reads:
        if r.is_input_value_port() and r.is_top_level_signal() and r.get_host_component() is top:
          preamble.append( ( delay, b ) )
          # We directly use the signal object as the inport vcd event
          event_vcd_netids[ r ] = [ signal_net_mapping[ r ] ]
          inport_vcds.append( r )

    for (u, v) in top._dag.all_constraints: # u -> v
      if u in V and v in V:
        if v in top._dsl.all_update_delay:
          triggers[u].append( ( 1, top._dsl.all_update_delay[v], v ) )
        else:
          triggers[u].append( ( 1, 0, v ) )

    top._sched.queue = []
    top._sched.hashset = set()
    top._sched.timestamp = 0
    top._sched.preamble = preamble
    top._sched.triggers = triggers

    def create_sim_delay( top, dump_vcd ):
      Q = top._sched.queue
      hashset  = top._sched.hashset
      preamble = top._sched.preamble
      triggers = top._sched.triggers
      vcd_file = top._vcd.vcd_file

      def sim_delay( delay ):
        time = top._sched.timestamp
        target_time = time + delay

        top._check_top_level_inports()

        # execute blocks that read input ports

        for delay, event in preamble:
          event()
          triggered_time = time + delay
          for p, t, e in triggers[event]:
            if (triggered_time, e) not in hashset:
              heappush( Q, ( triggered_time, p, t, e ) )
              hashset.add( (triggered_time, e) )

        for e in inport_vcds:
          dump_vcd( time, e )

        while Q:
          time, event_type, event_delay, event = Q[0]
          if time > target_time:
            break

          heappop( Q )
          hashset.remove( (time, event) )

          event()

          if event_type:
            triggered_time = time + event_delay
            for p, t, e in triggers[event]:
              if (triggered_time, e) not in hashset:
                heappush( Q, ( triggered_time, p, t, e ) )
                hashset.add( (triggered_time, e) )

            if event_delay == 0:
              dump_vcd( time, event )

          else: # flip
            dump_vcd( time, event )

        top._sched.timestamp = target_time
        vcd_file.flush()

      return sim_delay

    top.sim_delay = create_sim_delay( top, create_dump_vcd( top ) )
