"""
========================================================================
EventSchedulePass.py
========================================================================
Generate a simple schedule (no Mamba techniques here) based on the
DAG generated by some previous pass.

Author : Shunning Jiang
Date   : Dec 8, 2020
"""
import linecache, py
from collections import defaultdict
from heapq import heappush, heappop

from pymtl3.dsl.Component import Component
from pymtl3.dsl.NamedObject import NamedObject
from pymtl3.dsl.Connectable import Const, Interface, MethodPort, Signal
from pymtl3.dsl.errors import UpblkCyclicError
from pymtl3.extra.pypy import custom_exec
from pymtl3.passes.BasePass import BasePass, PassMetadata
from pymtl3.passes.errors import PassOrderError

"""
Delays can also be specified within an assignment statement as in

  p = #10 (a | b); // Example of intra-assignment delay

This statement is interpreted as follows
- First evaluate the right hand expression (a | b). Then wait for 10 units of time.
After this wait, assign the value of RHS to LHS. The above is called intra assignment delay. The above statement is equivalent to

  temp = (a | b); // evaluate the RHS and hold it temporarily
  #10; // Wait for 10 units of time
  p = temp; // Assign the temporary evaluation to LHS

"""

class EventSchedulePass( BasePass ):
  def __call__( self, top ):
    if not hasattr( top._dag, "all_constraints" ):
      raise PassOrderError( "all_constraints" )

    top._sched = PassMetadata()

    self.schedule( top )

  def schedule( self, top ):

    if not hasattr( top, "_sched" ):
      raise Exception( "Please create top._sched pass metadata namespace first!" )

    # First replace signals with variables, as we need to get the handle
    # of x._flip() of the real values

    signal_object_mapping = {}

    Q = [ (top, top) ]
    while Q:
      current_obj, host = Q.pop()
      if isinstance( current_obj, list ):
        for i, obj in enumerate( current_obj ):
          if isinstance( obj, Signal ):
            try:
              value = obj.default_value()
              if obj._dsl.needs_double_buffer:
                value <<= value
            except Exception as e:
              raise type(e)(str(e) + f' happens at {obj!r}')

            current_obj[i] = value

            signal_object_mapping[ obj ] = (current_obj, i, True, value)

          elif isinstance( obj, Component ):
            Q.append( (obj, obj) )
          elif isinstance( obj, (Interface, list) ):
            Q.append( (obj, host) )

      elif isinstance( current_obj, NamedObject ):
        for i, obj in current_obj.__dict__.items():
          if i[0] == '_': continue

          if isinstance( obj, Signal ):
            try:
              value = obj.default_value()
              if obj._dsl.needs_double_buffer:
                value <<= value
            except Exception as e:
              raise type(e)(str(e) + f' happens at {obj!r}')

            setattr( current_obj, i, value )
            signal_object_mapping[obj] = (current_obj, i, False, value)

          elif isinstance( obj, Component ):
            Q.append( (obj, obj) )
          elif isinstance( obj, (Interface, list) ):
            Q.append( (obj, host) )

    # Swap all Signal objects with actual data
    nets = top.get_all_value_nets()

    # First step is to consolidate all non-slice signals in the same net
    # by pointing them to the same object
    # TODO optimize for bitstruct fields. Essentially only sliced signals
    # should be excluded.
    for writer, signals in nets:
      residence = None

      # Find the residence value
      if isinstance( writer, Const ) or writer.is_top_level_signal():
        residence = writer
      else:
        for x in signals:
          if x.is_top_level_signal():
            residence = x
            break

      if residence is None:
        continue # whole net is slice

      if isinstance( residence, Const ):
        residence_value = residence._dsl.const
      else:
        residence_value = signal_object_mapping[ residence ][-1]

      # Replace top-level signals in the net with residence value

      for x in signals:
        if x is not residence and x.is_top_level_signal():
          # swap old value with new residence value

          current_obj, i, is_list, value = signal_object_mapping[ x ]
          signal_object_mapping[ x ] = (current_obj, i, is_list, residence_value)

          if is_list:
            current_obj[i] = residence_value
          else:
            setattr( current_obj, i, residence_value )

    # Construct the intra-cycle graph based on normal update blocks

    assert not top.get_all_update_ff()
    V = top._dag.final_upblks

    E   = set()
    Es  = { v: [] for v in V }
    InD = { v: 0  for v in V }

    for (u, v) in top._dag.all_constraints: # u -> v
      if u in V and v in V:
        InD[v] += 1
        Es[u].append( v )

    triggers = { v: [] for v in V }
    preamble = []

    for b, writes in top._dsl.all_upblk_writes.items():
      for w in writes:
        triggers[b].append( ( 0, 0, signal_object_mapping[w][-1]._flip ) )

    for b, reads in top._dsl.all_upblk_reads.items():
      if b in top._dsl.all_update_delay:
        delay = top._dsl.all_update_delay[b]
      else:
        delay = 0

      for r in reads:
        if r.is_input_value_port() and r.is_top_level_signal() and r.get_host_component() is top:
          preamble.append( ( delay, b ) )


    for b, es in Es.items():
      for e in es:
        if e in top._dsl.all_update_delay:
          triggers[b].append( ( 1, top._dsl.all_update_delay[e], e ) )
        else:
          triggers[b].append( ( 1, 0, e ) )

    top._sched.queue = []
    top._sched.hashset = set()
    top._sched.timestamp = 0
    top._sched.preamble = preamble
    top._sched.triggers = triggers

    def create_sim_delay( top ):
      Q = top._sched.queue
      hashset  = top._sched.hashset
      preamble = top._sched.preamble
      triggers = top._sched.triggers

      def sim_delay( delay ):
        time = top._sched.timestamp
        target_time = time + delay

        top._check_top_level_inports()

        # execute blocks that read input ports

        for delay, event in preamble:
          event()
          print("preamble", event)
          triggered_time = time + delay
          for p, t, e in triggers[event]:
            if (triggered_time, e) not in hashset:
              heappush( Q, ( triggered_time, p, t, e ) )
              hashset.add( (triggered_time, e) )

        while Q:
          time, event_type, event_delay, event = Q[0]
          if time > target_time:
            break
          print(time, event)
          heappop( Q )
          hashset.remove( (time, event) )

          event()

          if event_type:
            triggered_time = time + event_delay
            for p, t, e in triggers[event]:
              if (triggered_time, e) not in hashset:
                heappush( Q, ( triggered_time, p, t, e ) )
                hashset.add( (triggered_time, e) )

        top._sched.timestamp = target_time

      return sim_delay

    # Check top level input ports are invoked with @=
    inports = []
    objs    = []
    for x in top._dsl.all_signals:
      if x.is_input_value_port() and x.is_top_level_signal() and x.get_host_component() is top:
        inports.append( x )
        objs.append( signal_object_mapping[x][-1] )

    src = """
def check_top_level_inports():
  {}
""".format( "\n  ".join([ f"assert {x} is obj{i}, 'Please use @= to assign top level InPort top.{repr(x)[2:]}'"
                          for i, x in enumerate(inports) ]) )
    _locals = {}
    _globals = { f"obj{i}" : x for i, x in enumerate(objs) }
    _globals['s'] = top
    custom_exec( py.code.Source(src).compile(), _globals, _locals)
    top._check_top_level_inports = _locals['check_top_level_inports']

    top.sim_delay = create_sim_delay( top )
