#=========================================================================
# VerilogPlaceholderPass.py
#=========================================================================
# For each placeholder in the component hierarchy, set up default values,
# check if all configs are valid, and pickle the specified Verilog
# source files.
#
# Author : Peitian Pan
# Date   : Jan 27, 2020

import os
import re
from textwrap import dedent

from pymtl3.passes.PlaceholderPass import PlaceholderPass
from pymtl3.passes.PlaceholderConfigs import expand
from pymtl3.passes.backends.sverilog.VerilogPlaceholderConfigs import \
    VerilogPlaceholderConfigs
from pymtl3.passes.backends.sverilog.util.utility import get_component_unique_name
from pymtl3.passes.rtlir import RTLIRDataType as rdt
from pymtl3.passes.rtlir import RTLIRType as rt
from pymtl3.passes.rtlir import get_component_ifc_rtlir

class VerilogPlaceholderPass( PlaceholderPass ):

  def visit_placeholder( s, m ):
    irepr = get_component_ifc_rtlir( m )

    s.setup_default_configs( m, irepr )

    # after the previous setup step, placeholder `m` is guaranteed to have 
    # config_placeholder attribute.
    if m.config_placeholder.is_valid:
      s.check_valid( m, m.config_placeholder, irepr )
      s.pickle( m, m.config_placeholder, irepr )

  def setup_default_configs( s, m, irepr ):
    if not hasattr( m, 'config_placeholder' ):
      m.config_placeholder = VerilogPlaceholderConfigs()

    cfg = m.config_placeholder

    if cfg.is_valid:
      # If top_module is unspecified, infer it from the component and its
      # parameters. Note we need to make sure the infered top_module matches
      # the default translation result.
      if not cfg.top_module:
        cfg.top_module = get_component_unique_name( irepr )

      # Only try to infer the name of Verilog source file if both
      # flist and the source file are not specified.
      if not cfg.src_file and not cfg.v_flist:
        cfg.src_file = f"{cfg.top_module}.sv"

  def check_valid( s, m, cfg, irepr ):
    pmap, src, flist, include = \
        cfg.port_map, cfg.src_file, cfg.v_flist, cfg.v_include

    # Check params
    for param_name, value in cfg.params.items():
      assert isinstance( value, int ), \
          f'non-integer parameter {param_name} is not supported yet!'

    for param_name, value in cfg.params.items():
      assert isinstance( value, int ), \
          f'non-integer parameter {param_name} is not supported yet!'

    # Check port map
    all_ports = irepr.get_ports_packed()
    all_port_names = list(map(lambda x: x[0], irepr.get_ports_packed()))
    assert all(isinstance(p, rt.Port) and \
               isinstance(p.get_dtype(), rdt.Vector) for n, p in all_ports), \
        f"Port map option currently requires all ports of {irepr.get_name()}"\
        f" to be a non-array vector port."
    for name in pmap.keys():
      if name not in all_port_names:
        raise InvalidPassOptionValue("port_map", pmap, cfg.PassName,
          f"Port {name} does not exist in component {irepr.get_name()}!")

    # Check src_file
    if cfg.src_file:
      assert os.path.isfile(expand(cfg.src_file)), 'src_file should be a file path!'

    assert not cfg.v_flist, 'Placeholders backed by Verilog flist are not supported yet!'
    # Check v_flist
    if cfg.v_flist:
      assert os.path.isfile(expand(cfg.v_flist)), 'v_flist should be a file path!'

    # Check v_include
    if cfg.v_include:
      for include in cfg.v_include:
        assert os.path.isdir(expand(cfg.v_include)), 'v_include should be an array of dir paths!'

  def pickle( s, m, cfg, irepr ):
    # In the namespace m._placeholder_meta:
    #   pickled_source_file: path to the pickled Verilog source file
    #   pickled_top_module:  name of the top module in the pickled Verilog

    pickled_source_file = f'{cfg.top_module}_pickled.sv'
    if cfg.explicit_module_name:
      pickled_top_module = cfg.explicit_module_name
    else:
      pickled_top_module = f'{cfg.top_module}_wrapper'

    m._placeholder_meta.pickled_source_file = pickled_source_file
    m._placeholder_meta.pickled_top_module  = pickled_top_module

    orig_comp_name    = get_component_unique_name( irepr )
    pickle_dependency = s._get_dependent_verilog_modules( m, cfg, irepr )
    pickle_wrapper    = s._gen_verilog_wrapper( m, cfg, irepr, pickled_top_module )
    def_symbol        = pickled_top_module.upper()

    # The directives are there to prevent potential duplicated definitions
    pickle_template = dedent(
        '''\
            // This is a wrapper module that wraps PyMTL placeholder {orig_comp_name}
            // This file was generated by PyMTL VerilogPlaceholderPass
            #ifndef {def_symbol}
            #define {def_symbol}
            {pickle_dependency}
            {pickle_wrapper}
            #endif
        '''
    )

    with open( pickled_source_file, 'w' ) as fd:
      fd.write( pickle_template.format( **locals() ) )

  def _get_dependent_verilog_modules( s, m, cfg, irepr ):
    return s._import_sources( [cfg.src_file] )

  def _gen_verilog_wrapper( s, m, cfg, irepr, pickled_top_module ):
    p_map = cfg.get_port_map()
    no_clk = not cfg.has_clk
    no_reset = not cfg.has_reset

    _packed_ports = s._gen_packed_ports( irepr )
    packed_ports = \
        ([('clk', '' if no_clk else p_map('clk'), clk)] if no_clk else []) + \
        ([('reset', '' if no_reset else p_map('reset'), reset)] if no_reset else []) + \
        [ (n, p_map(n), p) for n, p in _packed_ports \
          if not (n == 'clk' and no_clk or n == 'reset' and no_reset)]

    if not cfg.params:
      parameters = irepr.get_params()
    else:
      parameters = cfg.params.items()

    # Port definitions of wrapper
    ports = [
      f"  {p.get_direction()} logic [{p.get_dtype().get_length()}-1:0]"\
      f" {name}{'' if idx == len(packed_ports)-1 else ','}" \
      for idx, (_, name, p) in enumerate(packed_ports) if name
    ]

    # Parameters passed to the module to be parametrized
    params = [
      f"    .{param}( {val} ){'' if idx == len(parameters)-1 else ','}"\
      for idx, (param, val) in enumerate(parameters)
    ]

    # Connections between top module and inner module
    connect_ports = [
      f"    .{name}( {name} ){'' if idx == len(packed_ports)-1 else ','}"\
      for idx, (_, name, p) in enumerate(packed_ports) if name
    ]

    lines = [
      f"module {pickled_top_module}",
      "(",
    ] + ports + [
      ");",
      f"  {cfg.top_module}",
      "  #(",
    ] + params + [
      "  ) wrapped_verilog_module",
      "  (",
    ] + connect_ports + [
      "  );",
      "endmodule",
    ]

    return '\n'.join( line for line in lines )

  #-----------------------------------------------------------------------
  # import_sources
  #-----------------------------------------------------------------------
  # The right way to do this is to use a recursive function like I have
  # done below. This ensures that files are inserted into the output stream
  # in the correct order. -cbatten
  
  # Regex to extract verilog filenames from `include statements
  
  s._include_re = re.compile( r'"(?P<filename>[\w/\.-]*)"' )
  
  def _output_verilog_file( s, include_path, verilog_file ):
    code = ""
    with open( verilog_file, 'r' ) as fp:
  
      short_verilog_file = verilog_file
      if verilog_file.startswith( include_path+"/" ):
        short_verilog_file = verilog_file[len(include_path+"/"):]
  
      code += '`line 1 "{}" 0\n'.format( short_verilog_file )
  
      line_num = 0
      for line in fp:
        line_num += 1
        if '`include' in line:
          filename = include_re.search( line ).group( 'filename' )
          fullname = os.path.join( include_path, filename )
          code += s._output_verilog_file( include_path, fullname )
          code += '\n'
          code += '`line {} "{}" 0\n'.format( line_num+1, short_verilog_file )
        else:
          code += line
    return code
  
  def _import_sources( s, source_list ):
    """Import Verilog source from all Verilog files source_list, as well
    as any source files specified by `include within those files.
    """

    code = ""
  
    if not source_list:
      return
  
    # We will use the first verilog file to find the root of PyMTL project
  
    first_verilog_file = source_list[0]
  
    # All verilog includes are relative to the root of the PyMTL project.
    # We identify the root of the PyMTL project by looking for the special
    # .pymtl-sim-root file.
  
    _path = os.path.dirname( first_verilog_file )
    special_file_found = False
    include_path = os.path.dirname( os.path.abspath( first_verilog_file ) )
    while include_path != "/":
      if os.path.exists( include_path + os.path.sep + ".pymtl-sim-root" ):
        special_file_found = True
        sys.path.insert(0,include_path)
        break
      include_path = os.path.dirname(include_path)
  
    # If we could not find the special .pymtl-python-path file, then assume
    # the include directory is the same as the directory that contains the
    # first verilog file.
  
    if not special_file_found:
      include_path = os.path.dirname( os.path.abspath( first_verilog_file ) )
  
    # Regex to extract verilog filenames from `include statements
  
    include_re = re.compile( r'"(?P<filename>[\w/\.-]*)"' )
  
    # Iterate through all source files and add any `include files to the
    # list of source files to import.
  
    for source in source_list:
      code += s._output_verilog_file( include_path, source )

    return code

  #-----------------------------------------------------------------------
  # _gen_packed_ports
  #-----------------------------------------------------------------------

  def _get_rtype( s, _rtype ):
    if isinstance( _rtype, rt.Array ):
      n_dim = _rtype.get_dim_sizes()
      rtype = _rtype.get_sub_type()
    else:
      n_dim = []
      rtype = _rtype
    return n_dim, rtype

  def _mangle_port( s, id_, port, n_dim ):
    if not n_dim:
      return [ ( id_, port ) ]
    else:
      return [ ( id_, rt.Array( n_dim, port ) ) ]

  def _mangle_interface( s, id_, ifc, n_dim ):
    if not n_dim:
      ret = []
      all_properties = ifc.get_all_properties_packed()
      for name, rtype in all_properties:
        _n_dim, _rtype = s._get_rtype( rtype )
        if isinstance( _rtype, rt.Port ):
          ret += s._mangle_port( id_+"__"+name, _rtype, _n_dim )
        elif isinstance( _rtype, rt.InterfaceView ):
          ret += s._mangle_interface( id_+"__"+name, _rtype, _n_dim )
        else:
          assert False, f"{name} is not interface(s) or port(s)!"
    else:
      ret = []
      for i in range( n_dim[0] ):
        ret += s._mangle_interface( id_+"__"+str(i), ifc, n_dim[1:] )
    return ret

  def _gen_packed_ports( s, irepr ):
    """Return a list of (name, rt.Port) that has all ports of `irepr`.

    This method performs SystemVerilog backend-specific name mangling and
    returns all ports that appear in the interface of component `irepr`.
    Each tuple contains a port or an array of port that has any data type
    allowed in RTLIRDataType.
    """
    packed_ports = []
    ports = irepr.get_ports_packed()
    ifcs = irepr.get_ifc_views_packed()
    for id_, port in ports:
      p_n_dim, p_rtype = s._get_rtype( port )
      packed_ports += s._mangle_port( id_, p_rtype, p_n_dim )
    for id_, ifc in ifcs:
      i_n_dim, i_rtype = s._get_rtype( ifc )
      packed_ports += s._mangle_interface( id_, i_rtype, i_n_dim )
    return packed_ports
