#=========================================================================
# SVStructuralTranslatorL1.py
#=========================================================================
"""Provide SystemVerilog structural translator implementation."""

import re
import os

from pymtl3.datatypes import Bits
from pymtl3.passes.backends.generic.structural.StructuralTranslatorL1 import (
    StructuralTranslatorL1,
)
from pymtl3.passes.rtlir import RTLIRType as rt
from pymtl3.passes.rtlir import RTLIRDataType as rdt

from ...errors import SVerilogReservedKeywordError
from ...util.utility import get_component_unique_name, make_indent


def _get_rtype( _rtype ):
  if isinstance( _rtype, rt.Array ):
    n_dim = _rtype.get_dim_sizes()
    rtype = _rtype.get_sub_type()
  else:
    n_dim = []
    rtype = _rtype
  return n_dim, rtype

def mangle_port( id_, port, n_dim ):
  if not n_dim:
    return [ ( id_, port ) ]
  else:
    return [ ( id_, rt.Array( n_dim, port ) ) ]

def mangle_interface( id_, ifc, n_dim ):
  if not n_dim:
    ret = []
    all_properties = ifc.get_all_properties_packed()
    for name, rtype in all_properties:
      _n_dim, _rtype = _get_rtype( rtype )
      if isinstance( _rtype, rt.Port ):
        ret += mangle_port( id_+"__"+name, _rtype, _n_dim )
      elif isinstance( _rtype, rt.InterfaceView ):
        ret += mangle_interface( id_+"__"+name, _rtype, _n_dim )
      else:
        assert False, f"{name} is not interface(s) or port(s)!"
  else:
    ret = []
    for i in range( n_dim[0] ):
      ret += mangle_interface( id_+"__"+str(i), ifc, n_dim[1:] )
  return ret

def gen_packed_ports( rtype ):
  """Return a list of (name, rt.Port ) that has all ports of `rtype`.

  This method performs SystemVerilog backend-specific name mangling and
  returns all ports that appear in the interface of component `rtype`.
  Each tuple contains a port or an array of port that has any data type
  allowed in RTLIRDataType.
  """
  packed_ports = []
  ports = rtype.get_ports_packed()
  ifcs = rtype.get_ifc_views_packed()
  for id_, port in ports:
    p_n_dim, p_rtype = _get_rtype( port )
    packed_ports += mangle_port( id_, p_rtype, p_n_dim )
  for id_, ifc in ifcs:
    i_n_dim, i_rtype = _get_rtype( ifc )
    packed_ports += mangle_interface( id_, i_rtype, i_n_dim )
  return packed_ports

class SVStructuralTranslatorL1( StructuralTranslatorL1 ):

  def check_decl( s, name, msg ):
    if s.is_sverilog_reserved( name ):
      raise SVerilogReservedKeywordError( name, msg )

  #-----------------------------------------------------------------------
  # Placeholder
  #-----------------------------------------------------------------------

  def rtlir_tr_placeholder_wrapper( s, rtype, cfg ):
    wrapper = ''
    p_map = lambda x: x if x not in cfg.portmap else cfg.portmap[x]
    no_clk = not cfg.has_clk
    no_reset = not cfg.has_reset
    _packed_ports = gen_packed_ports( rtype )
    packed_ports = \
        ([('clk', '' if no_clk else p_map('clk'), clk)] if no_clk else []) + \
        ([('reset', '' if no_reset else p_map('reset'), reset)] if no_reset else []) + \
        [ (n, p_map(n), p) for n, p in _packed_ports \
          if not (n == 'clk' and no_clk or n == 'reset' and no_reset)]

    if len(cfg.params) == 0:
      parameters = rtype.get_params()
    else:
      parameters = cfg.params

    # Port definitions of top-level wrapper
    ports = [
      f"  {p.get_direction()} logic [{p.get_dtype().get_length()}-1:0]"\
      f" {name}{'' if idx == len(packed_ports)-1 else ','}" \
      for idx, (_, name, p) in enumerate(packed_ports) if name
    ]
    # Parameters passed to the module to be parametrized
    params = [
      f"    .{param}( {val} ){'' if idx == len(parameters)-1 else ','}"\
      for idx, (param, val) in enumerate(parameters)
    ]
    # Connections between top module and inner module
    connect_ports = [
      f"    .{name}( {name} ){'' if idx == len(packed_ports)-1 else ','}"\
      for idx, (_, name, p) in enumerate(packed_ports) if name
    ]
    lines = [
      "// This is a top-level module that wraps a parametrized module",
      "// This file is generated by PyMTL SystemVerilog import pass",
      f"module {cfg.verilog_name}",
      "(",
    ] + ports + [
      ");",
      f"  {cfg.top_module}",
      "  #(",
    ] + params + [
      "  ) wrapped_verilog_module",
      "  (",
    ] + connect_ports + [
      "  );",
      "endmodule",
    ]

    wrapper = '\n'.join( line for line in lines )
    return wrapper

  def rtlir_tr_placeholder_dependency( s, m, placeholder_cfg ):

    #-----------------------------------------------------------------------
    # import_sources
    #-----------------------------------------------------------------------
    # The right way to do this is to use a recursive function like I have
    # done below. This ensures that files are inserted into the output stream
    # in the correct order. -cbatten
    
    # Regex to extract verilog filenames from `include statements
    
    include_re = re.compile( r'"(?P<filename>[\w/\.-]*)"' )
    
    def output_verilog_file( include_path, verilog_file ):
      code = ""
      with open( verilog_file, 'r' ) as fp:
    
        short_verilog_file = verilog_file
        if verilog_file.startswith( include_path+"/" ):
          short_verilog_file = verilog_file[len(include_path+"/"):]
    
        code += '`line 1 "{}" 0\n'.format( short_verilog_file )
    
        line_num = 0
        for line in fp:
          line_num += 1
          if '`include' in line:
            filename = include_re.search( line ).group( 'filename' )
            fullname = os.path.join( include_path, filename )
            code += output_verilog_file( include_path, fullname )
            code += '\n'
            code += '`line {} "{}" 0\n'.format( line_num+1, short_verilog_file )
          else:
            code += line
      return code
    
    def import_sources( source_list ):
      """Import Verilog source from all Verilog files source_list, as well
      as any source files specified by `include within those files.
      """

      code = ""
    
      if not source_list:
        return
    
      # We will use the first verilog file to find the root of PyMTL project
    
      first_verilog_file = source_list[0]
    
      # All verilog includes are relative to the root of the PyMTL project.
      # We identify the root of the PyMTL project by looking for the special
      # .pymtl-sim-root file.
    
      _path = os.path.dirname( first_verilog_file )
      special_file_found = False
      include_path = os.path.dirname( os.path.abspath( first_verilog_file ) )
      while include_path != "/":
        if os.path.exists( include_path + os.path.sep + ".pymtl-sim-root" ):
          special_file_found = True
          sys.path.insert(0,include_path)
          break
        include_path = os.path.dirname(include_path)
    
      # If we could not find the special .pymtl-python-path file, then assume
      # the include directory is the same as the directory that contains the
      # first verilog file.
    
      if not special_file_found:
        include_path = os.path.dirname( os.path.abspath( first_verilog_file ) )
    
      # Regex to extract verilog filenames from `include statements
    
      include_re = re.compile( r'"(?P<filename>[\w/\.-]*)"' )
    
      # Iterate through all source files and add any `include files to the
      # list of source files to import.
    
      for source in source_list:
        code += output_verilog_file( include_path, source )

      return code
    
      # for verilog_file in source_list:
      #
      #   print(verilog_file)
      #   with open( verilog_file, 'r' ) as fp:
      #     for line in fp:
      #       if '`include' in line:
      #         filename = include_re.search( line ).group( 'filename' )
      #         fullname = os.path.join( include_path, filename )
      #         if fullname not in source_list:
      #           source_list.append( fullname )
    
      # Iterate through all source files in reverse order and write out all
      # source code from imported/`included verilog files. Do this in reverse
      # order to (hopefully) resolve any `define dependencies, and remove any
      # lines with `include statements.
    
      # for verilog_file in reversed( source_list ):
      #
      #   # We remove the include directory from the verilog file name to make
      #   # error reporting by Verilator more succinct. -cbatten
      #
      #   short_verilog_file = verilog_file
      #   if verilog_file.startswith( include_path+"/" ):
      #     short_verilog_file = verilog_file[len(include_path+"/"):]
      #
      #   src = '`line 1 "{}" 0\n'.format( short_verilog_file )
      #
      #   with open( verilog_file, 'r' ) as fp:
      #     for line in fp:
      #       if '`include' not in line:
      #         src += line
      #       else:
      #         src += "// " + line
      #
      #   print( src, file=o )

    return import_sources( [placeholder_cfg.src_file] )

  #-----------------------------------------------------------------------
  # Data types
  #-----------------------------------------------------------------------

  def rtlir_tr_vector_dtype( s, dtype ):
    msb = dtype.get_length() - 1
    return {
      'def'  : '',
      'nbits' : dtype.get_length(),
      'const_decl' : f'[{msb}:0] {{id_}}',
      'decl' : f'logic [{msb}:0] {{id_}}',
      'raw_dtype' : dtype
    }

  def rtlir_tr_unpacked_array_type( s, Type ):
    if Type is None:
      return { 'def' : '', 'decl' : '', 'n_dim':[] }
    else:
      array_dim = "".join( f"[0:{size-1}]" for size in Type.get_dim_sizes() )
      return {
        'def'  : '',
        'decl' : ' ' + array_dim,
        'n_dim' : Type.get_dim_sizes()
      }

  #-----------------------------------------------------------------------
  # Declarations
  #-----------------------------------------------------------------------

  def rtlir_tr_port_decls( s, port_decls ):
    make_indent( port_decls, 1 )
    return ',\n'.join( port_decls )

  def rtlir_tr_port_decl( s, id_, Type, array_type, dtype ):
    _dtype = Type.get_dtype()
    if array_type:
      template = "Note: port {id_} has data type {_dtype}"
    else:
      n_dim = array_type['n_dim']
      template = "Note: {n_dim} array of ports {id_} has data type {_dtype}"
    s.check_decl( id_, template.format( **locals() ) )
    return Type.get_direction() + ' ' + \
           dtype['decl'].format( **locals() ) + array_type['decl']

  def rtlir_tr_wire_decls( s, wire_decls ):
    make_indent( wire_decls, 1 )
    return '\n'.join( wire_decls )

  def rtlir_tr_wire_decl( s, id_, Type, array_type, dtype ):
    _dtype = Type.get_dtype()
    if array_type:
      template = "Note: wire {id_} has data type {_dtype}"
    else:
      n_dim = array_type['n_dim']
      template = "Note: {n_dim} array of wires {id_} has data type {_dtype}"
    s.check_decl( id_, template.format( **locals() ) )
    return dtype['decl'].format( **locals() ) + array_type['decl'] + ';'

  def rtlir_tr_const_decls( s, const_decls ):
    make_indent( const_decls, 1 )
    return '\n'.join( const_decls )

  def gen_array_param( s, n_dim, dtype, array ):
    if not n_dim:
      if isinstance( dtype, rdt.Vector ):
        return s._literal_number( dtype.get_length(), array )
      else:
        assert False, f'{array} is not an integer or a BitStruct!'
    else:
      ret = []
      for _idx, idx in enumerate( range( n_dim[0] ) ):
        ret.append( s.gen_array_param( n_dim[1:], dtype, array[idx] ) )
      cat_str = ", ".join( ret )
      return f"'{{ {cat_str} }}"

  def rtlir_tr_const_decl( s, id_, Type, array_type, dtype, value ):
    _dtype = Type.get_dtype()
    if array_type:
      template = "Note: constant {id_} has data type {_dtype}"
    else:
      n_dim = array_type['n_dim']
      template = "Note: {n_dim} array of constants {id_} has data type {_dtype}"
    s.check_decl( id_, template.format( **locals() ) )
    _dtype = dtype['const_decl'].format( **locals() ) + array_type['decl']
    _value = s.gen_array_param( array_type['n_dim'], dtype['raw_dtype'], value )

    return f'localparam {_dtype} = {_value};'

  #-----------------------------------------------------------------------
  # Connections
  #-----------------------------------------------------------------------

  def rtlir_tr_connections( s, connections ):
    make_indent( connections, 1 )
    return '\n'.join( connections )

  def rtlir_tr_connection( s, wr_signal, rd_signal ):
    return f'assign {rd_signal} = {wr_signal};'

  #-----------------------------------------------------------------------
  # Signal operations
  #-----------------------------------------------------------------------

  def rtlir_tr_bit_selection( s, base_signal, index ):
    # Bit selection
    return f'{base_signal}[{index}]'

  def rtlir_tr_part_selection( s, base_signal, start, stop ):
    # Part selection
    _stop = stop-1
    return f'{base_signal}[{_stop}:{start}]'

  def rtlir_tr_port_array_index( s, base_signal, index ):
    return f'{base_signal}[{index}]'

  def rtlir_tr_wire_array_index( s, base_signal, index ):
    return f'{base_signal}[{index}]'

  def rtlir_tr_const_array_index( s, base_signal, index ):
    return f'{base_signal}[{index}]'

  def rtlir_tr_current_comp_attr( s, base_signal, attr ):
    return f'{attr}'

  def rtlir_tr_current_comp( s, comp_id, comp_rtype ):
    return ''

  #-----------------------------------------------------------------------
  # Miscs
  #-----------------------------------------------------------------------

  def rtlir_tr_var_id( s, var_id ):
    return var_id.replace( '[', '__' ).replace( ']', '' )

  def _literal_number( s, nbits, value ):
    value = int( value )
    return f"{nbits}'d{value}"

  def rtlir_tr_literal_number( s, nbits, value ):
    return s._literal_number( nbits, value )

  def rtlir_tr_component_unique_name( s, c_rtype ):
    return get_component_unique_name( c_rtype )
