#=========================================================================
# test_wrapper
#=========================================================================
# Wrappers for testing rtl model.
# 
# Author : Yixiao Zhang
#   Date : March 24, 2019

from pymtl import *
from template import *
from pymtl.dsl.ComponentLevel6 import method_port, ComponentLevel6

def _mangleName( method_name, port_name ):
  return method_name + "_" + port_name



#-------------------------------------------------------------------------
# Result
#-------------------------------------------------------------------------
class Result():
  pass

  def __eq__( self, obj ):
    if not isinstance( obj, Result ):
      return False
    return self.__dict__ == obj.__dict__

#-------------------------------------------------------------------------
# RTLAdapter
#-------------------------------------------------------------------------
class RTL2CLWrapper( ComponentLevel6 ):

  def _construct( s ):
    for method_name, method_spec in s.method_specs.iteritems():
      s._add_method( method_spec )
    ComponentLevel6._construct( s )


  def construct( s, rtl_model, method_specs ):
    s.model = rtl_model
    s.method_specs = method_specs
    s.ports = {}
    s.reset_called =  Bits1()
    s._constraints = []

    if hasattr(s.model, "reset"):
      @s.update
      def update_reset():
        s.model.reset = s.reset_called
        s.reset_called = 0

    for method_name, method_spec in s.method_specs.iteritems():
      s._add_ports( method_spec )
      s._gen_update( method_spec )

  def _rename( s, f, newname ):
    f.__name__ = newname


  def _add_ports( s, method_spec ):
    ports = {}
    setattr( s, _mangleName( method_spec.method_name, "called" ), Bits1( 0 ) )
    setattr( s, _mangleName( method_spec.method_name, "rdy" ), Bits1( 0 ) )
    for arg, dtype in method_spec.args.iteritems():
      ports[ arg ] = dtype
      setattr( s, _mangleName( method_spec.method_name, arg ),
               dtype )
    for ret, dtype in method_spec.rets.iteritems():
      setattr( s, _mangleName( method_spec.method_name, ret ),
               dtype )
    s.ports[ method_spec.method_name ] = ports


  def _gen_update( s, method_spec ):

    assign_args = ""
    for arg in method_spec.args.keys():
      assign_args += assign_args_tmpl.format(
          method_name=method_spec.method_name, arg=arg )

    assign_rets = ""
    for ret in method_spec.rets.keys():
      assign_rets += assign_rets_tmpl.format(
          method_name=method_spec.method_name, ret=ret )

    updates = update_tmpl.format(
        assign_rets=assign_rets,
        assign_args=assign_args,
        method_name=method_spec.method_name )

    # The problem with generating update block code is that
    # inpect.getsource will throw exception. To work around that we create
    # a fake filename and write the source code to linecache
    # This is a hacky workaround that might change later
    filename = '<dynamic-123456>'
    exec ( compile( updates, filename, 'exec' ), locals() )
    lines = [ line + '\n' for line in updates.splitlines() ]
    import linecache
    linecache.cache[ filename ] = ( len( updates ), None, lines, filename )

    # These three lines try to rewrite update_rdy using setattr/getattr
    # All other upblks are still generated by exec & compile
    # Uncommenting them will make the test pass
    def update_rdy():
      setattr(s, _mangleName( method_spec.method_name, "rdy" ), getattr(s.model, method_spec.method_name).rdy )
    s.add_constraints( U( update_rdy ) < RD( getattr(s, _mangleName( method_spec.method_name, "rdy" ) ) ) )

    # Rename to avoid name conflicts
    s._rename( update_rdy, "update_" + method_spec.method_name + "_rdy_adapter" )
    s._rename( update, "update_" + method_spec.method_name + "_adapter" )
    s._rename( update_rets, "update_" + method_spec.method_name + "_rets_adapter" )
    s._rename( update_args, "update_" + method_spec.method_name + "_args_adapter" )

    s.update( update ) 
    s.update( update_rdy ) 

    rdy_func = s.__dict__[ method_spec.method_name ].rdy
    method_func = s.__dict__[ method_spec.method_name ]

    if method_spec.args:
      s.update( update_args )
      s.add_constraints( 
        M( method_func ) < U( update_args )
      )

    if method_spec.rets:
      s.update( update_rets )
      s.add_constraints( 
        U( update_rets ) < M( method_func )
      )
    for ret in method_spec.rets.keys():
      ret_signal = s.model.__dict__[ method_spec.method_name ].__dict__[ret]
      s.add_constraints(  WR( ret_signal ) < U( update_rets )  )


    s.add_constraints(
      U( update_rdy ) < M( rdy_func ),
      U( update_rdy ) < M( rdy_func ),
      M( rdy_func ) < U( update ),
      M( method_func ) < U( update )
    )


  def _add_method( self, method_spec ):
    
    method_name = method_spec.method_name
    assign_args = ""
    for arg in method_spec.args.keys():
      assign_args += arg_tmpl.format( arg=arg, method=method_name )

    method_code = method_tmpl.format(
        method=method_name, assign_args=assign_args )

    method_spec = method_spec
    def method(*args, **kwargs):
      namespace = {'method_spec': method_spec, 'kwargs': kwargs, 'self': self}
      if not kwargs and args:
        count = 0
        for arg in method_spec.args.keys():
          kwargs[arg] = args[count]
          count += 1
      exec ( compile( method_code, "<string>", 'exec' ), namespace )
      ret_list =  [ self.__dict__[_mangleName( method_name, ret )] for ret in method_spec.rets.keys() ]
      if ret_list:
        return ret_list[0]

    method = method_port( lambda s: s.__dict__[method_name + "_rdy"] )(method)
    setattr( method, "__name__", method_name )
    
    setattr( self, method_name, method )

  def line_trace( s ):
    return s.model.line_trace()