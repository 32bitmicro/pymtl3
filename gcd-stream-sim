#!/usr/bin/env python
#=========================================================================
# gcd-stream-sim [options]
#=========================================================================
#
#  -h --help           Display this message
#
#  --impl              {flat, conn, bundle}
#  --cycle             number of million cycles, default=10 -- 10M
#
# Author : Christopher Batten
# Date   : February 5, 2015

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------
import argparse, os, sys, timeit

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional commane line arguments for the simulator

  p.add_argument( "--impl",   default="flat", choices=["flat","conn","bundle"] )
  p.add_argument( "--cycle",  default=10, type=int )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

from pymtl import *
from GcdUnitUpImpl import GcdUnit as GcdUnitFlat
from GcdUnitUp     import GcdUnit as GcdUnitConn
from GcdUnitBundle import GcdUnit as GcdUnitBundle
from pclib.update  import StreamSource as Source, StreamSink as Sink
from pclib.bundle  import StreamSource as BSource, StreamSink as BSink

class SimHarness( Updates ):

  def __init__( s, model ):

    s.src  = Source( 2 )
    s.gcd  = model()
    s.sink = Sink()

    s.gcd.req_val   |= s.src.val
    s.gcd.req_msg_a |= s.src.msg[0]
    s.gcd.req_msg_b |= s.src.msg[1]
    s.src.rdy       |= s.gcd.req_rdy

    s.sink.val      |= s.gcd.resp_val
    s.gcd.resp_rdy  |= s.sink.rdy
    s.sink.msg      |= s.gcd.resp_msg

  def done( s ):
    return s.src.done() and s.sink.done()

  def line_trace( s ):
    return s.src.line_trace()+" >>> "+s.gcd.line_trace()+" >>> "+s.sink.line_trace()

class SimHarnessBundle( Updates ):

  def __init__( s, model ):

    s.src  = BSource( 2 )
    s.gcd  = model()
    s.sink = BSink()

    s.gcd.req  |= s.src.out
    s.gcd.resp |= s.sink.in_

  def done( s ):
    return s.src.done() and s.sink.done()

  def line_trace( s ):
    return s.src.line_trace()+" >>> "+s.gcd.line_trace()+" >>> "+s.sink.line_trace()

def main():
  opts = parse_cmdline()

  model_impl_dict = {
    "flat"   : GcdUnitFlat,
    "conn"   : GcdUnitConn,
    "bundle" : GcdUnitBundle,
  }

  if "bundle" in opts.impl:
    th = SimHarnessBundle( model_impl_dict[ opts.impl ] )
  else:
    th = SimHarness( model_impl_dict[ opts.impl ] )

  th.elaborate()
  th.print_schedule()

  ncycles = opts.cycle * 1000000

  start_time = timeit.default_timer()
  for x in xrange(ncycles):
    th.cycle()
  end_time = timeit.default_timer()
  print "- Total cycles   : %d cycles" % ncycles
  print "- Execution time : %.5f seconds" % (end_time - start_time)
  print "- Cycle/second   : %.2f cps" % (ncycles/(end_time - start_time))

main()
